# -*- coding: utf-8 -*-
"""G191210012(2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oVcWT8XA0W147zfdtFe6NdLNQ_3-ig8O

:G191210012 /
Ali Yusuf Akbay /
Bilgisayar Mühendisliği 1. öğretim A grubu

DOĞRU FİYAT BELİRLEMEK
Günümüzde alışverişin internet ortamına gerçekleşmesi sebebiyle fiyat belirleme konusunda artık daha doğru karar vermemizi sağlayan büyük veri kaynakları oluşmaktadır. Eskiden evini satmak isteyen bir bireyin doğru fiyat belirleme konusunda güvenebileceğini tek kaynak yakın zamanda çevre mahallesindeki ev satışları olmak zorundaydı şimdi ise fiyatlandırma konusunda çok daha başarılı makine öğrenmesi sistemleri kullanılabilir insanın düşünebileceğinden çok daha fazla faktörün fiyat belirleme konusundaki etkisi ölçülebilir. Bu hem bir ürünü satın alacak kişi için hemde satan kişi için bir güven ve kolaylık oluşturacaktır. Ticaretin daha hızlı ve tutarlı bir şekilde akmasını sağlıyacak yatırım yapmayı daha kolay ve basit bir hale getirecektir.

## VERİYİ ANLAMAK
"""

#Veriyi temizlemek,düzenlemek ve incelemek için gerekli kütüphaneleri yüklüyor
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#colab çok fazla veri olunca 3 nokta koyarak hepsini göstermiyordu bu kod ile bütün verileri görmem mümkün oldu
pd.set_option("display.max_rows", None, "display.max_columns", None)

#verinin yüklenmesi ve veriye bir önbakış
train_data=pd.read_csv('train.csv')
test_data=pd.read_csv('test.csv')
train_data.head()

#verideki satır ve sütün sayıları yani kaç adet veri var ve bu verilerin kaçar tane özellkileri var
print(train_data.shape)
print(test_data.shape)
#train datasette 81 sütün varken test datasette 80 tane bulunmakta çünkü test datasında House_Price sütünü bulunamamkta
#bu bir yarışma olduğu için test datasetindeki tahminlerimle yarışmaya katılacam o yüzden House_Price değişkeni test içerisinde yok

#verideki öznitelikler hakkında bilgiler
train_data.info()

#verideki sayısal özniteliklerin bazı statistik bilgileri
test_data.describe()

#verideki sayısal özniteliklerin bazı statistik bilgileri
train_data.describe()

"""# VERİNİN HAZIRLANMASI

"""

#Train data setinde hangi özniteliğin kaç adet Null değeri bulunmakta?
train_data.isnull().sum()

#boş değerler için bir heatmap verilerin içindeki Null değerlerin dağılımını gösteriyor
sns.heatmap(train_data.isnull(), yticklabels=False)

#PoolQC, Fence, MiscFeature öznitelikleri çok fazla boş değere sahip oldukları için tablodan sildim
train_data.drop(['PoolQC','Fence','MiscFeature'],axis=1,inplace=True)
test_data.drop(['PoolQC','Fence','MiscFeature'],axis=1,inplace=True)
#Her yaptığım değişiklikleri test ve train datasetinde aynı anda ekliyorum

train_data.drop(['GarageYrBlt'],axis=1,inplace=True)
test_data.drop(['GarageYrBlt'],axis=1,inplace=True)

#test data setinde hangi özniteliğin kaç adet Null değeri bulunmakta?
test_data.isnull().sum()

#Null değerlerin sütünlardaki oranlarını tespit edip test_data_na içerisine attım ve bunları bir barplot ile görselleştirdim
test_data_na = (train_data.isnull().sum() / len(train_data)) * 100
test_data_na = test_data_na.drop(test_data_na[test_data_na == 0].index).sort_values(ascending=False)
sns.barplot(x=test_data_na.index, y=test_data_na)

#test datasetinde Alley değerinde çok fazla null değer olduğu için tablodan sildim
train_data.drop(['Alley'],axis=1,inplace=True)
test_data.drop(['Alley'],axis=1,inplace=True)

#Id değeri bizim herhangi bir işimize yaramayan unique value bir değer olduğu için tablolardan sildim
train_data.drop(['Id'],axis=1,inplace=True)
test_data.drop(['Id'],axis=1,inplace=True)

"""
# aykırı değerler
"""

#sütünların standart sapmalarını bulup çoktan aza doğru sıraladım
train_data.std().sort_values(ascending=False)

#Bir scatter plot ile aykırı değerlerin tespitini yaptım
fig, ax = plt.subplots()
ax.scatter(x = train_data['GrLivArea'], y = train_data['SalePrice'])

#aykırı değerler silindi
train_data = train_data.drop(train_data[(train_data['GrLivArea']>4000) & (train_data['SalePrice']<300000)].index)

#Diğer aykırı değerleri bulmak için boxplot kullandım
#Lotarea'nın aykırı değerleri silinmeden önceki boxplot grafiği
sns.boxplot(train_data['LotArea'])

#100000 değerinin üzerindeki değerleri aykırı değer olarak saydım ve onları sildim
train_data = train_data.drop(train_data[(train_data['LotArea']>100000)].index)

#Lotarea'nın aykırı değerleri silindikten sonraki boxplot grafiği
sns.boxplot(train_data['LotArea'])

#MiscVal'ın aykırı değerleri silinmeden önceki boxplot grafiği
sns.boxplot(train_data['MiscVal'])

#8000 değerinin üzerindeki değerleri aykırı değer olarak saydım ve onları sildim
train_data = train_data.drop(train_data[(train_data['MiscVal']>8000)].index)

#MiscVal'ın aykırı değerleri silindikten sonraki boxplot grafiği
sns.boxplot(train_data['MiscVal'])

#bütün silme işlemleri bittikten sonraki kalan satır sayısına baktım
train_data.shape

"""# Sütün silme işleri tamamlandı sırada boş değerler halledilecek

"""

sns.heatmap(train_data.isnull(), yticklabels=False)

#Boş olan sayısal değereleri ortalama değer ile kategorik değerleri ise en çok tekrarlayan kategori ile değiştirdim
train_data['LotFrontage']=test_data['LotFrontage'].fillna(train_data['LotFrontage'].mean())
train_data['BsmtCond']=test_data['BsmtCond'].fillna(test_data['BsmtCond'].mode()[0])
train_data['BsmtQual']=test_data['BsmtQual'].fillna(test_data['BsmtQual'].mode()[0])
train_data['FireplaceQu']=test_data['FireplaceQu'].fillna(test_data['FireplaceQu'].mode()[0])
train_data['GarageType']=test_data['GarageType'].fillna(test_data['GarageType'].mode()[0])
train_data['GarageFinish']=test_data['GarageFinish'].fillna(test_data['GarageFinish'].mode()[0])
train_data['GarageQual']=test_data['GarageQual'].fillna(test_data['GarageQual'].mode()[0])
train_data['GarageCond']=test_data['GarageCond'].fillna(test_data['GarageCond'].mode()[0])
train_data['MasVnrType']=test_data['MasVnrType'].fillna(test_data['MasVnrType'].mode()[0])
train_data['MasVnrArea']=test_data['MasVnrArea'].fillna(test_data['MasVnrArea'].mode()[0])
train_data['BsmtExposure']=test_data['BsmtExposure'].fillna(test_data['BsmtExposure'].mode()[0])
train_data['BsmtFinType2']=test_data['BsmtFinType2'].fillna(test_data['BsmtFinType2'].mode()[0])

sns.heatmap(test_data.isnull(), yticklabels=False)

#Boş olan sayısal değereleri ortalama değer ile kategorik değerleri ise en çok tekrarlayan kategori ile değiştirdim
#Aynı işlemleri test dataseti içinde gerçeklestirdim
test_data['LotFrontage']=test_data['LotFrontage'].fillna(test_data['LotFrontage'].mean())
test_data['MSZoning']=test_data['MSZoning'].fillna(test_data['MSZoning'].mode()[0])
test_data['BsmtCond']=test_data['BsmtCond'].fillna(test_data['BsmtCond'].mode()[0])
test_data['BsmtQual']=test_data['BsmtQual'].fillna(test_data['BsmtQual'].mode()[0])
test_data['FireplaceQu']=test_data['FireplaceQu'].fillna(test_data['FireplaceQu'].mode()[0])
test_data['GarageType']=test_data['GarageType'].fillna(test_data['GarageType'].mode()[0])
test_data['GarageFinish']=test_data['GarageFinish'].fillna(test_data['GarageFinish'].mode()[0])
test_data['GarageQual']=test_data['GarageQual'].fillna(test_data['GarageQual'].mode()[0])
test_data['GarageCond']=test_data['GarageCond'].fillna(test_data['GarageCond'].mode()[0])
test_data['MasVnrType']=test_data['MasVnrType'].fillna(test_data['MasVnrType'].mode()[0])
test_data['MasVnrArea']=test_data['MasVnrArea'].fillna(test_data['MasVnrArea'].mode()[0])
test_data['BsmtExposure']=test_data['BsmtExposure'].fillna(test_data['BsmtExposure'].mode()[0])
test_data['BsmtFinType2']=test_data['BsmtFinType2'].fillna(test_data['BsmtFinType2'].mode()[0])
test_data['Utilities']=test_data['Utilities'].fillna(test_data['Utilities'].mode()[0])
test_data['Exterior1st']=test_data['Exterior1st'].fillna(test_data['Exterior1st'].mode()[0])
test_data['Exterior2nd']=test_data['Exterior2nd'].fillna(test_data['Exterior2nd'].mode()[0])
test_data['BsmtFinType1']=test_data['BsmtFinType1'].fillna(test_data['BsmtFinType1'].mode()[0])
test_data['BsmtFinSF1']=test_data['BsmtFinSF1'].fillna(test_data['BsmtFinSF1'].mean())
test_data['BsmtFinSF2']=test_data['BsmtFinSF2'].fillna(test_data['BsmtFinSF2'].mean())
test_data['BsmtUnfSF']=test_data['BsmtUnfSF'].fillna(test_data['BsmtUnfSF'].mean())
test_data['TotalBsmtSF']=test_data['TotalBsmtSF'].fillna(test_data['TotalBsmtSF'].mean())
test_data['BsmtFullBath']=test_data['BsmtFullBath'].fillna(test_data['BsmtFullBath'].mode()[0])
test_data['BsmtHalfBath']=test_data['BsmtHalfBath'].fillna(test_data['BsmtHalfBath'].mode()[0])
test_data['KitchenQual']=test_data['KitchenQual'].fillna(test_data['KitchenQual'].mode()[0])
test_data['Functional']=test_data['Functional'].fillna(test_data['Functional'].mode()[0])
test_data['GarageCars']=test_data['GarageCars'].fillna(test_data['GarageCars'].mean())
test_data['GarageArea']=test_data['GarageArea'].fillna(test_data['GarageArea'].mean())
test_data['SaleType']=test_data['SaleType'].fillna(test_data['SaleType'].mode()[0])

#bütün işlemlerden sonra kalan Null değerli satırları sildim
train_data.dropna(inplace=True)
test_data.dropna(inplace=True)
train_data.shape

"""# Sayısal değerleri ölçeklendirme (SCALLING)"""

#Sayısal değerleri bir liste içerinde depoladım ve içerisinden SalePrice'ı çıkardım
numeric = train_data.select_dtypes(include=np.number).columns.tolist()
numeric.remove('SalePrice')
numeric

#ölçeklendirmeden önceki min, max ve mean değerleri
train_data[numeric].describe()

#ölçeklendirmeden önceki LotArea değerlinin tablosu
sns.displot(train_data['LotArea'])

#Scaller olarak MinMaxScaller Kullandım
from sklearn.preprocessing import MinMaxScaler


scaler = MinMaxScaler()

scaler.fit(train_data[numeric])

train_data[numeric] = scaler.transform(train_data[numeric])
test_data[numeric] = scaler.transform(test_data[numeric])
##ölçeklendirmeden sonraki min, max ve mean değerleri
train_data[numeric].describe()

#ölçeklendirmeden sonraki LotArea değerlinin tablosu
sns.displot(train_data['LotArea'])

"""# Kategorik değerleri sayısala çevirme"""

#bütün kategorik değerleri columns değişkeninde topladım
categoric=['MSZoning','Street','LotShape','LandContour','Utilities','LotConfig','LandSlope','Neighborhood',
         'Condition2','BldgType','Condition1','HouseStyle','SaleType',
        'SaleCondition','ExterCond',
         'ExterQual','Foundation','BsmtQual','BsmtCond','BsmtExposure','BsmtFinType1','BsmtFinType2',
        'RoofStyle','RoofMatl','Exterior1st','Exterior2nd','MasVnrType','Heating','HeatingQC',
         'CentralAir',
         'Electrical','KitchenQual','Functional',
         'FireplaceQu','GarageType','GarageFinish','GarageQual','GarageCond','PavedDrive']
len(categoric)

"""One-Hot coding tekniği, her bir kategori sütünündaki farklı kategoriler için bir sütün açıp onları var/yok yani 1/0 olarak değerlerniriyor örneğin:
![resim_2021-12-13_141435.png](data:image/png;base64,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)
"""

#kategorik değerleri One-Hot Encoding tekniği ile makine tarafından okunabilen sayısal değerlere çeviren fonksiyon
def category_onehot_multcols(multcolumns):
    df_final=All_data
    i=0
    for fields in multcolumns:
        
        df1=pd.get_dummies(All_data[fields],drop_first=True)
        
        All_data.drop([fields],axis=1,inplace=True)
        if i==0:
            df_final=df1.copy()
        else:
            
            df_final=pd.concat([df_final,df1],axis=1)
        i=i+1
       
        
    df_final=pd.concat([All_data,df_final],axis=1)
        
    return df_final

#test ve train data setinde farklı kategorik değerler olduğu için 2 data seti birleştirip sonra One-Hot Encoding kodunu uyguladım
All_data = pd.concat([train_data,test_data],axis=0)

#All_data set içerisinde daha önceden columns değişkenine kaydettiğim sütünları tek tek One-Hot Encoding'e göre ayarlıyorum
All_data=category_onehot_multcols(categoric)

All_data.shape

All_data.head(5)

#One-Hot Encoding sonrası birbirinin aynısı kopya sütünları sildim
All_data =All_data.loc[:,~All_data.columns.duplicated()]
All_data.shape

#Train ve test data setini tekrardan böldüm
train_data=All_data.iloc[:1413,:]
test_data=All_data.iloc[1413:,:]

#Data'yı tekrardan 2'ye ayırırken verileri birbirine karıştırmış mıyım diye konrtol ettim (test datasetinde salePrice değişkeni Null, trainde ise Null olmaması gerekir)
train_data['SalePrice'].tail()

test_data['SalePrice'].head()

#SalesPrice sütünü 2 data seti birleştirdiğimizden dolayı test data içerisinde eklenmiş onu çıkarttım
test_data.drop(['SalePrice'],axis=1,inplace=True)

"""# MODEL OLUŞTURMA


"""

#Train data'yı X ve Y değerlerine böldüm
x=train_data.drop(['SalePrice'],axis=1)
y=train_data['SalePrice']

#Model oluşturmak ve data seti bölmek için gerekli kütüphaneleri yükledim
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split

#model denemek için datayı gerekli parçalara böldüm
x_train, x_test, y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=2)

#ilk denediğim model basit bir linear reggresion modeli oldu
Lin_model=LinearRegression()
Lin_model.fit(x_train,y_train)

#modelin doğruluğunu test ettim

y_predict = Lin_model.predict(x_test)
mean_squared_error(y_test,y_predict,squared=False)

#2. denediğim model Random Forest oldu
from sklearn.ensemble import RandomForestRegressor

forest_model = RandomForestRegressor(random_state=1)
forest_model.fit(x_train, y_train)
RandomForestPredictions = forest_model.predict(x_test)
mean_absolute_error(y_test, RandomForestPredictions)

#3. denediğim model XGBRegressor oldu
from xgboost import XGBRegressor

XG_model = XGBRegressor(max_depth=4)
XG_model.fit(x_train, y_train)

XGpredictions = XG_model.predict(x_test)
mean_absolute_error(XGpredictions, y_test)

#En başarılı modele göre test_data içerisindeki verileri için tahminde bulunup  yarışmaya katıldım
final_result = my_model.predict(test_data)
final_result = pd.DataFrame(final_result)
submission = pd.read_csv('sample_submission.csv')
final_result = pd.concat([submission['Id'],final_result],axis=1)
final_result.columns = ['Id','SalePrice']
final_result.to_csv('sample_submission.csv',index=False)